# HIT项目前端开发规范

## 📋 目录

- [1. ID类型规范](#1-id类型规范)
- [2. API接口规范](#2-api接口规范)
- [3. 路由参数规范](#3-路由参数规范)
- [4. TypeScript类型规范](#4-typescript类型规范)
- [5. 组件开发规范](#5-组件开发规范)
- [6. 状态管理规范](#6-状态管理规范)
- [7. 错误处理规范](#7-错误处理规范)
- [8. 代码检查清单](#8-代码检查清单)

---

## 1. ID类型规范

### 🚫 禁止事项

```typescript
// ❌ 错误：使用Number()转换ID
const projectId = Number(route.params.id);
const userId = Number(userStore.userId);

// ❌ 错误：在接口中定义ID为number类型
export interface ProjectInfo {
  projectId?: number; // 错误
}

// ❌ 错误：函数参数使用number类型
export function getProject(projectId: number): AxiosPromise<ProjectInfo>;
```

### ✅ 正确做法

```typescript
// ✅ 正确：直接使用string类型
const projectId = route.params.id as string;
const userId = userStore.userId; // 保持原始类型

// ✅ 正确：接口中ID使用string类型
export interface ProjectInfo {
  projectId?: string; // 正确
}

// ✅ 正确：函数参数使用string类型
export function getProject(projectId: string): AxiosPromise<ProjectInfo>;

// ✅ 正确：支持兼容性的联合类型
export function getUserSkills(userId: string | number);
```

### 📝 ID类型规则

1. **所有主键ID在前端统一使用 `string` 类型**
2. **路由参数ID直接使用 `as string` 断言**
3. **API接口中的ID参数和返回值都使用 `string` 类型**
4. **数据库自增ID、雪花ID等长整型ID必须使用 `string` 类型**
5. **如需兼容性，使用 `string | number` 联合类型**

---

## 2. API接口规范

### 🏗️ 接口定义模板

```typescript
// 数据接口模板
export interface [EntityName]Info {
  [entityName]Id?: string;          // 主键ID使用string
  // 其他字段...
  createTime?: string;              // 时间字段使用string
  updateTime?: string;
}

// 查询参数接口模板
export interface [EntityName]Query {
  pageNum?: number;
  pageSize?: number;
  // 查询条件...
}

// 表单接口模板
export interface [EntityName]Form {
  [entityName]Id?: string;          // 主键ID使用string
  // 表单字段...
}
```

### 🔧 API函数模板

```typescript
// 查询详情
export function get[EntityName](id: string): AxiosPromise<[EntityName]Info> {
  return request({
    url: `/hit/[entityName]/${id}`,
    method: 'get'
  });
}

// 新增
export function add[EntityName](data: [EntityName]Form): AxiosPromise<string> {
  return request({
    url: '/hit/[entityName]',
    method: 'post',
    data: data
  });
}

// 更新
export function update[EntityName](data: [EntityName]Form): AxiosPromise<void> {
  return request({
    url: '/hit/[entityName]',
    method: 'put',
    data: data
  });
}

// 删除
export function del[EntityName](ids: string[]): AxiosPromise<void> {
  return request({
    url: `/hit/[entityName]/${ids}`,
    method: 'delete'
  });
}
```

---

## 3. 路由参数规范

### ✅ 路由参数处理

```typescript
// 组件中获取路由参数
const route = useRoute();
const entityId = route.params.id as string;

// 参数验证
onMounted(() => {
  if (!entityId) {
    ElMessage.error('参数无效');
    router.back();
    return;
  }
  loadData();
});

// 路由跳转
const handleView = (id: string) => {
  router.push(`/hit/module/detail/${id}`);
};
```

### 🔒 参数验证规则

1. **总是对路由参数进行空值检查**
2. **使用 `as string` 进行类型断言**
3. **参数无效时提供用户友好的错误提示**
4. **跳转路由时确保传递正确的参数类型**

---

## 4. TypeScript类型规范

### 🎯 类型定义原则

```typescript
// ✅ 严格类型定义
interface UserInfo {
  userId: string; // 必需字段不使用可选
  userName: string;
  email?: string; // 可选字段使用?
  status: 'active' | 'inactive'; // 使用联合类型限制值
}

// ✅ 泛型使用
interface ApiResponse<T> {
  code: number;
  msg: string;
  data: T;
}

// ✅ 枚举使用
enum ProjectStatus {
  ACTIVE = 'active',
  PAUSED = 'paused',
  COMPLETED = 'completed'
}
```

### 📋 类型检查清单

- [ ] 所有ID字段使用 `string` 类型
- [ ] 必需字段不使用可选操作符 `?`
- [ ] 状态字段使用联合类型或枚举
- [ ] 时间字段统一使用 `string` 类型
- [ ] 复杂对象使用接口定义
- [ ] API返回值使用泛型包装

---

## 5. 组件开发规范

### 🧩 组件结构模板

```vue
<template>
  <div class="[component-name]-container">
    <!-- 页面头部 -->
    <div class="page-header">
      <!-- 头部内容 -->
    </div>

    <!-- 主要内容 -->
    <div class="main-content">
      <!-- 内容区域 -->
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, computed, onMounted } from 'vue';
import { useRouter, useRoute } from 'vue-router';
import { ElMessage } from 'element-plus';
import { useUserStore } from '@/store/modules/user';

// 1. 导入类型和API
import type { [EntityName]Info, [EntityName]Form } from '@/api/hit/[entityName]';
import { get[EntityName], add[EntityName] } from '@/api/hit/[entityName]';

// 2. 路由和Store
const router = useRouter();
const route = useRoute();
const userStore = useUserStore();

// 3. 响应式数据
const loading = ref(false);
const entityId = route.params.id as string;

// 4. 表单数据
const form = reactive<[EntityName]Form>({
  // 初始化表单字段
});

// 5. 计算属性
const computedValue = computed(() => {
  // 计算逻辑
});

// 6. 方法定义
const loadData = async () => {
  // 数据加载逻辑
};

const handleSubmit = async () => {
  // 提交逻辑
};

// 7. 生命周期
onMounted(() => {
  if (entityId) {
    loadData();
  }
});
</script>

<style scoped lang="scss">
.[component-name]-container {
  // 样式定义
}
</style>
```

### 🔧 组件开发检查清单

- [ ] 使用 `<script setup lang="ts">` 语法
- [ ] 导入必要的类型定义
- [ ] 路由参数使用 `as string` 断言
- [ ] 响应式数据使用正确的API
- [ ] 异步操作添加loading状态
- [ ] 错误处理使用ElMessage
- [ ] 组件名使用kebab-case

---

## 6. 状态管理规范

### 🏪 Store使用规范

```typescript
// ✅ 正确使用用户信息
const userStore = useUserStore();

// 获取当前用户ID（保持原始类型）
const currentUserId = userStore.userId;

// 用户登录状态检查
if (!currentUserId) {
  ElMessage.error('用户未登录，请先登录');
  return;
}

// API调用时直接传递
const response = await getUserData(currentUserId);
```

### 🚫 避免硬编码

```typescript
// ❌ 错误：硬编码用户ID
const response = await getUserData(1);

// ❌ 错误：硬编码权限判断
if (userId === 1) {
  /* 超级管理员逻辑 */
}

// ✅ 正确：使用动态用户ID
const response = await getUserData(userStore.userId);

// ✅ 正确：使用权限判断
if (userStore.roles.includes('SUPER_ADMIN')) {
  /* 管理员逻辑 */
}
```

---

## 7. 错误处理规范

### 🛡️ 统一错误处理

```typescript
// API调用错误处理模板
const loadData = async () => {
  loading.value = true;
  try {
    const response = await getEntityData(entityId);
    if (response.code === 200) {
      // 成功处理
      data.value = response.data;
    } else {
      ElMessage.error(response.msg || '获取数据失败');
    }
  } catch (error) {
    console.error('获取数据失败:', error);
    ElMessage.error('获取数据失败，请重试');
  } finally {
    loading.value = false;
  }
};

// 表单提交错误处理模板
const handleSubmit = async () => {
  try {
    await formRef.value?.validate();
    loading.value = true;

    const response = await submitData(form);
    if (response.code === 200) {
      ElMessage.success('操作成功');
      router.back();
    } else {
      ElMessage.error(response.msg || '操作失败');
    }
  } catch (error) {
    console.error('操作失败:', error);
    ElMessage.error('操作失败，请检查表单信息');
  } finally {
    loading.value = false;
  }
};
```

---

## 8. 代码检查清单

### 📝 开发前检查清单

- [ ] 确认API接口设计，所有ID字段使用string类型
- [ ] 确认数据库表结构，长整型ID对应前端string类型
- [ ] 确认路由设计，参数传递使用string类型

### 🔍 编码时检查清单

- [ ] 路由参数获取：`route.params.id as string`
- [ ] API接口定义：所有ID字段为 `string` 类型
- [ ] 函数参数：ID参数使用 `string` 或 `string | number`
- [ ] 数据传递：避免使用 `Number()` 转换ID
- [ ] 用户信息：使用 `userStore.userId` 而非硬编码
- [ ] 错误处理：添加try-catch和用户友好提示
- [ ] 加载状态：异步操作添加loading状态

### ✅ 提交前检查清单

- [ ] TypeScript编译无错误
- [ ] ESLint检查通过
- [ ] 所有API调用添加错误处理
- [ ] 用户交互有适当的反馈
- [ ] 路由跳转参数类型正确
- [ ] 没有硬编码的ID值
- [ ] 没有使用Number()转换ID

### 🧪 测试检查清单

- [ ] 大整数ID显示正确（不丢失精度）
- [ ] 路由参数传递正确
- [ ] API请求参数类型正确
- [ ] 错误情况处理正常
- [ ] 用户权限判断正确
- [ ] 分页功能工作正常

---

## 📚 参考示例

### 完整的CRUD页面示例

```typescript
// 实体管理页面标准模板
export default defineComponent({
  name: 'EntityManagement',
  setup() {
    // 1. 基础设置
    const router = useRouter();
    const route = useRoute();
    const userStore = useUserStore();

    // 2. 响应式数据
    const loading = ref(false);
    const entityList = ref<EntityInfo[]>([]);
    const total = ref(0);
    const dialogVisible = ref(false);
    const isEdit = ref(false);

    // 3. 表单数据
    const form = reactive<EntityForm>({
      entityId: undefined
      // 其他字段...
    });

    // 4. 查询参数
    const queryParams = reactive({
      pageNum: 1,
      pageSize: 10
      // 查询条件...
    });

    // 5. 数据加载
    const loadEntityList = async () => {
      loading.value = true;
      try {
        const response = await getEntityList(queryParams);
        if (response.code === 200) {
          entityList.value = response.rows || [];
          total.value = response.total || 0;
        }
      } catch (error) {
        console.error('获取列表失败:', error);
        ElMessage.error('获取列表失败');
      } finally {
        loading.value = false;
      }
    };

    // 6. CRUD操作
    const handleAdd = () => {
      isEdit.value = false;
      resetForm();
      dialogVisible.value = true;
    };

    const handleEdit = (entity: EntityInfo) => {
      isEdit.value = true;
      Object.assign(form, entity);
      dialogVisible.value = true;
    };

    const handleDelete = async (id: string) => {
      try {
        await ElMessageBox.confirm('确定要删除吗？', '确认删除');
        await deleteEntity([id]);
        ElMessage.success('删除成功');
        loadEntityList();
      } catch (error) {
        if (error !== 'cancel') {
          console.error('删除失败:', error);
          ElMessage.error('删除失败');
        }
      }
    };

    // 7. 生命周期
    onMounted(() => {
      loadEntityList();
    });

    return {
      // 导出所需的响应式数据和方法
    };
  }
});
```

---

## 🎯 总结

遵循此规范可以避免：

1. ✅ ID类型精度丢失问题
2. ✅ 硬编码用户ID问题
3. ✅ 类型安全问题
4. ✅ 错误处理缺失问题
5. ✅ 代码一致性问题

**每次创建新模块时，请严格按照此规范执行，并使用检查清单进行自检！**
